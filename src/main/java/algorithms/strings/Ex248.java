package algorithms.strings;

// На второй год из английских слов изымут все удвоенные буквы: ee изменят на i, oo - на u,
// a в остальных комбинациях будут просто писать одну букву вместо двух одинаковых.
// Такие замены также будут делать строго в порядке слева направо.
// Так, слово ooo превратится в uo, а oou — просто в u (в нем сначала oo заменится на u, а затем uu — на u),
// слово iee превратится в i (в нем сначала ee заменится на i, а затем ii — на i).
//
// На третий год на конце слова станут опускать букву е,
// если она не единственная буква в слове.
//
// Наконец, завершением реформы станет отмена артиклей (в английском языке три артикля: а, an и the).
// При этом удаляться эти артикли будут только тогда, когда они в исходном тексте были словами a, an, the.
// То есть, например, текст the table после реформ первых трех лет превратиться в th tabl,
// а после реформы четвертого года — просто в tabl. А слово aaaaa после реформы первых лет станет словом a,
// но поскольку изначально оно не было словом a (артиклем), то оно в итоге так и останется словом a.
//
//Напишите программу, которая будет переводить классический английский текст на Eвроинглиш.

// Входные данные
//
// Во входном файле INPUT.TXT записана одна строка текста,
// состоящая не более чем из 200 символов: английских строчных и заглавных букв,
// пробелов и знаков препинания (в тексте могут встречаться: точка, запятая,
// вопросительный и восклицательный знаки, двоеточие, тире, точка с запятой,
// открывающаяся и закрывающаяся скобки, апострофы, кавычки). Заглавные буквы могут
// встречаться только в начале слова. Нигде подряд не могут стоять два пробела.
// В начале и в конце строки не может стоять пробел. Слова отделяются друг от друга
// пробелами и/или знаками препинания.

import java.util.LinkedList;
import java.util.stream.Collectors;

// Выходные данные
//
// В выходной файл OUTPUT.TXT нужно выдать преобразованную строку при ограничениях:
//
//    начинаться с заглавной буквы должны те и только те слова, которые начинались с заглавной буквы в исходном тексте;
//    не должно встречаться двух пробелов подряд;
//    пробелы между словами и знаками препинания должны остаться там и только там, где они были в исходной строке, в начале и в конце строки пробелов быть не должно.
public class Ex248 {

    // 1. Первоочередной задачей будет избавление от буквы c,
    // которая в сочетаниях сi и сe будет изменяться на s,
    // в сочетании ck — опускаться, а в остальных случаях заменяться на k.
    // При этом все замены будут производиться в строгом порядке слева направо.
    // То есть, например, в слове success сначала первая из двух букв c заменится на k, а затем вторая — на s, т
    // о есть получится suksess. А слово cck превратится в kk.
    //
    //
    // TODO 1. Избавление от буквы "с"
    //  ci/ce -> s
    //  ck -> ''
    //  c -> k
    //  cck -> kk
    //  success -> suksess (c -> k, c -> s)
    public static String doEuroEnglish(String str) {
        LinkedList<Character> sb = new LinkedList<>();
        for (int i = 0; i < str.length(); i++) {
            switch (str.charAt(i)) {
                case 'i':
                case 'e': {
                    if (sb.getLast() == 'c') {
                        sb.removeLast();
                        sb.addLast('s');
                    } else {
                        sb.addLast(str.charAt(i));
                    }
                    continue;
                }
                case 'k': {
                    if (sb.getLast() == 'c') {
                        sb.removeLast();
                    }
                    continue;
                }
                case 'c': {
                    if (i + 1 < str.length()) {
                        if (str.charAt(i + 1) == 'c') {
                            sb.addLast('k');
                        } else if (str.charAt(i + 1) != 'i' && str.charAt(i + 1) != 'e' && str.charAt(i + 1) != 'k') {
                            sb.addLast('k');
                        } else {
                            sb.addLast('c');
                        }
                    } else {
                        sb.addLast('k');
                    }
                    continue;
                }
                default:
                    sb.addFirst(str.charAt(i));
            }
        }
        return sb.stream()
                .map(Object::toString)
                .collect(Collectors.joining());
    }

    public static void main(String[] args) {
    }
}
